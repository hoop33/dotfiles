{"mode":"editor","version":1,"windowDimensions":{"x":446,"y":22,"width":1024,"height":1178},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/rwarner/.vimbundles/lusty/plugin","buffers":[{"text":"\"    Copyright: Copyright (C) 2008 Stephen Bach\n\"               Permission is hereby granted to use and distribute this code,\n\"               with or without modifications, provided that this copyright\n\"               notice is copied with it. Like anything else that's free,\n\"               lusty-juggler.vim is provided *as is* and comes with no\n\"               warranty of any kind, either expressed or implied. In no\n\"               event will the copyright holder be liable for any damages\n\"               resulting from the use of this software.\n\"\n\" Name Of File: lusty-juggler.vim\n\"  Description: Dynamic Buffer Switcher Vim Plugin\n\"   Maintainer: Stephen Bach <http://items.sjbach.com/about>\n\" Contributors: Juan Frias, Bartosz Leper, Marco Barberis, Vincent Driessen,\n\"               Martin Wache, Johannes Holzfuß, Adam Rutkowski, Carlo Teubner,\n\"               lilydjwg, Leonid Shevtsov, Giuseppe Rota, Göran Gustafsson,\n\"               Chris Lasher, Guy Haskin Fernald, Thibault Duplessis, Gabriel\n\"               Pettier\n\"\n\" Release Date: February 29, 2012\n\"      Version: 1.5.1\n\"\n\"        Usage:\n\"                 <Leader>lj  - Opens the buffer juggler.\n\"\n\"               You can also use this command:\n\"\n\"                 \":LustyJuggler\"\n\"\n\"               To suppress the default mapping, set this option:\n\"\n\"                 let g:LustyJugglerDefaultMappings = 0\n\"\n\"               When launched, the command bar at bottom is replaced with a\n\"               new bar showing the names of currently-opened buffers in\n\"               most-recently-used order.\n\"\n\"               By default, LustyJuggler follows the QWERTY layout, and\n\"               buffers are mapped to these keys:\n\"\n\"                   1st|2nd|3rd|4th|5th|6th|7th|8th|9th|10th\n\"                   ----------------------------------------\n\"                   a   s   d   f   g   h   j   k   l   ;\n\"                   1   2   3   4   5   6   7   8   9   0\n\"\n\"               So if you type \"f\" or \"4\", the fourth buffer name will be\n\"               highlighted and the bar will shift to center it as necessary\n\"               (and show more of the buffer names on the right).\n\"\n\"               If you want to switch to that buffer, press \"f\" or \"4\" again\n\"               or press \"<ENTER>\".  Alternatively, press one of the other\n\"               mapped keys to highlight another buffer.  To open the buffer\n\"               in a new split, press \"b\" for horizontal or \"v\" for vertical.\n\"\n\"               To display the key with the name of the buffer, add one of\n\"               the following lines to your .vimrc:\n\"\n\"                 let g:LustyJugglerShowKeys = 'a'   (for alpha characters)\n\"                 let g:LustyJugglerShowKeys = 1     (for digits)\n\"\n\"               To cancel the juggler, press any of \"q\", \"<ESC>\", \"<C-c\",\n\"               \"<BS>\", \"<Del>\", or \"<C-h>\".\n\"\n\"               LustyJuggler also supports the Dvorak, Colemak, Bépo and aerty\n\"               keyboard layouts. To enable this feature, place the one of the\n\"               following in your .vimrc:\n\"\n\"                 let g:LustyJugglerKeyboardLayout = \"dvorak\"\n\"                 let g:LustyJugglerKeyboardLayout = \"colemak\"\n\"                 let g:LustyJugglerKeyboardLayout = \"bépo\"\n\"                 let g:LustyJugglerKeyboardLayout = \"azerty\"\n\"\n\"               With the layout set to \"dvorak\", the buffer mapping is as\n\"               follows:\n\"\n\"                   1st|2nd|3rd|4th|5th|6th|7th|8th|9th|10th\n\"                   ----------------------------------------\n\"                   a   o   e   u   i   d   h   t   n   s\n\"                   1   2   3   4   5   6   7   8   9   0\n\"\n\"               With the layout set to \"colemak\", the buffer mapping is as\n\"               follows:\n\"\n\"                   1st|2nd|3rd|4th|5th|6th|7th|8th|9th|10th\n\"                   ----------------------------------------\n\"                   a   r   s   t   d   h   n   e   i   o\n\"                   1   2   3   4   5   6   7   8   9   0\n\"\n\"               With the layout set to \"bépo\", the buffer mapping is as\n\"               follows:\n\"\n\"                   1st|2nd|3rd|4th|5th|6th|7th|8th|9th|10th\n\"                   ----------------------------------------\n\"                   a   u   i   e   ,   t   s   r   n   m\n\"                   1   2   3   4   5   6   7   8   9   0\n\"\n\"               With the layout set to \"azerty\", the buffer mapping is as\n\"               follows:\n\"\n\"                   1st|2nd|3rd|4th|5th|6th|7th|8th|9th|10th\n\"                   ----------------------------------------\n\"                   q   s   d   f   g   j   k   l   m   ù\n\"                   1   2   3   4   5   6   7   8   9   0\n\"\n\"               LustyJuggler can act very much like <A-Tab> window switching.\n\"               To enable this mode, add the following line to your .vimrc:\n\"\n\"                 let g:LustyJugglerAltTabMode = 1\n\"\n\"               Then, given the following mapping:\n\"\n\"                 noremap <silent> <A-s> :LustyJuggler<CR>\n\"\n\"               Pressing \"<A-s>\" will launch the LustyJuggler with the\n\"               previous buffer highlighted. Typing \"<A-s>\" again will cycle\n\"               to the next buffer (in most-recently used order), and\n\"               \"<ENTER>\" will open the highlighted buffer.  For example, the\n\"               sequence \"<A-s><Enter>\" will open the previous buffer, and\n\"               \"<A-s><A-s><Enter>\" will open the buffer used just before the\n\"               previous buffer, and so on.\n\"\n\"        Bonus: This plugin also includes the following command, which will\n\"               immediately switch to your previously used buffer:\n\"\n\"                 \":LustyJugglePrevious\"\n\"\n\"               This is similar to the \":b#\" command, but accounts for the\n\"               common situation where the previously used buffer (#) has\n\"               been killed and is thus inaccessible.  In that case, it will\n\"               instead switch to the buffer used before that one (and on down\n\"               the line if that buffer has been killed too).\n\"\n\"\n\" Install Details:\n\"\n\" Copy this file into $HOME/.vim/plugin directory so that it will be sourced\n\" on startup automatically.\n\"\n\" Note! This plugin requires Vim be compiled with Ruby interpretation.  If you\n\" don't know if your build of Vim has this functionality, you can check by\n\" running \"vim --version\" from the command line and looking for \"+ruby\".\n\" Alternatively, just try sourcing this script.\n\"\n\" If your version of Vim does not have \"+ruby\" but you would still like to\n\" use this plugin, you can fix it.  See the \"Check for Ruby functionality\"\n\" comment below for instructions.\n\"\n\" If you are using the same Vim configuration and plugins for multiple\n\" machines, some of which have Ruby and some of which don't, you may want to\n\" turn off the \"Sorry, LustyJuggler requires ruby\" warning.  You can do so\n\" like this (in .vimrc):\n\"\n\"   let g:LustyJugglerSuppressRubyWarning = 1\n\"\n\"\n\" Contributing:\n\"\n\" Patches and suggestions welcome.  Note: lusty-juggler.vim is a generated\n\" file; if you'd like to submit a patch, check out the Github development\n\" repository:\n\"\n\"    http://github.com/sjbach/lusty\n\"\n\"\n\" GetLatestVimScripts: 2050 1 :AutoInstall: lusty-juggler.vim\n\"\n\" TODO:\n\" - Add TAB recognition back.\n\" - Add option to open buffer immediately when mapping is pressed (but not\n\"   release the juggler until the confirmation press).\n\" - Have the delimiter character settable.\n\"   - have colours settable?\n\n\" Exit quickly when already loaded.\nif exists(\"g:loaded_lustyjuggler\")\n  finish\nendif\n\nif &compatible\n  echohl ErrorMsg\n  echo \"LustyJuggler is not designed to run in &compatible mode;\"\n  echo \"To use this plugin, first disable vi-compatible mode like so:\\n\"\n\n  echo \"   :set nocompatible\\n\"\n\n  echo \"Or even better, just create an empty .vimrc file.\"\n  echohl none\n  finish\nendif\n\nif exists(\"g:FuzzyFinderMode.TextMate\")\n  echohl WarningMsg\n  echo \"Warning: LustyJuggler detects the presence of fuzzyfinder_textmate;\"\n  echo \"that plugin often interacts poorly with other Ruby plugins.\"\n  echo \"If LustyJuggler gives you an error, you can probably fix it by\"\n  echo \"renaming fuzzyfinder_textmate.vim to zzfuzzyfinder_textmate.vim so\"\n  echo \"that it is last in the load order.\"\n  echohl none\nendif\n\n\" Check for Ruby functionality.\nif !has(\"ruby\")\n  if !exists(\"g:LustyExplorerSuppressRubyWarning\") ||\n      \\ g:LustyExplorerSuppressRubyWarning == \"0\"\n  if !exists(\"g:LustyJugglerSuppressRubyWarning\") ||\n      \\ g:LustyJugglerSuppressRubyWarning == \"0\"\n    echohl ErrorMsg\n    echon \"Sorry, LustyJuggler requires ruby.  \"\n    echon \"Here are some tips for adding it:\\n\"\n\n    echo \"Debian / Ubuntu:\"\n    echo \"    # apt-get install vim-ruby\\n\"\n\n    echo \"Fedora:\"\n    echo \"    # yum install vim-enhanced\\n\"\n\n    echo \"Gentoo:\"\n    echo \"    # USE=\\\"ruby\\\" emerge vim\\n\"\n\n    echo \"FreeBSD:\"\n    echo \"    # pkg_add -r vim+ruby\\n\"\n\n    echo \"Windows:\"\n    echo \"    1. Download and install Ruby from here:\"\n    echo \"       http://www.ruby-lang.org/\"\n    echo \"    2. Install a Vim binary with Ruby support:\"\n    echo \"       http://segfault.hasno.info/vim/gvim72.zip\\n\"\n\n    echo \"Manually (including Cygwin):\"\n    echo \"    1. Install Ruby.\"\n    echo \"    2. Download the Vim source package (say, vim-7.0.tar.bz2)\"\n    echo \"    3. Build and install:\"\n    echo \"         # tar -xvjf vim-7.0.tar.bz2\"\n    echo \"         # ./configure --enable-rubyinterp\"\n    echo \"         # make && make install\\n\"\n\n    echo \"(If you just wish to stifle this message, set the following option:\"\n    echo \"  let g:LustyJugglerSuppressRubyWarning = 1)\"\n    echohl none\n  endif\n  endif\n  finish\nendif\n\nlet g:loaded_lustyjuggler = \"yep\"\n\n\" Commands.\ncommand LustyJuggler :call <SID>LustyJugglerStart()\ncommand LustyJugglePrevious :call <SID>LustyJugglePreviousRun()\n\n\" Deprecated command names.\ncommand JugglePrevious :call\n  \\ <SID>deprecated('JugglePrevious', 'LustyJugglePrevious')\n\nfunction! s:deprecated(old, new)\n  echohl WarningMsg\n  echo \":\" . a:old . \" is deprecated; use :\" . a:new . \" instead.\"\n  echohl none\nendfunction\n\n\n\" Default mappings.\nif !exists(\"g:LustyJugglerDefaultMappings\")\n  let g:LustyJugglerDefaultMappings = 1\nendif\n\nif g:LustyJugglerDefaultMappings == 1\n  nmap <silent> <Leader>lj :LustyJuggler<CR>\nendif\n\n\" Vim-to-ruby function calls.\nfunction! s:LustyJugglerStart()\n  ruby LustyJ::profile() { $lusty_juggler.run }\nendfunction\n\nfunction! s:LustyJugglerKeyPressed(code_arg)\n  ruby LustyJ::profile() { $lusty_juggler.key_pressed }\nendfunction\n\nfunction! s:LustyJugglerCancel()\n  ruby LustyJ::profile() { $lusty_juggler.cleanup }\nendfunction\n\nfunction! s:LustyJugglePreviousRun()\n  ruby LustyJ::profile() { $lj_buffer_stack.juggle_previous }\nendfunction\n\n\" Setup the autocommands that handle buffer MRU ordering.\naugroup LustyJuggler\n  autocmd!\n  autocmd BufAdd,BufEnter * ruby LustyJ::profile() { $lj_buffer_stack.push }\n  autocmd BufDelete * ruby LustyJ::profile() { $lj_buffer_stack.pop }\n  autocmd BufWipeout * ruby LustyJ::profile() { $lj_buffer_stack.pop }\naugroup End\n\n\" Used to work around a flaw in Vim's ruby bindings.\nlet s:maparg_holder = 0\nlet s:maparg_dict_holder = { }\n\nruby << EOF\n\nrequire 'pathname'\n\n$LUSTY_PROFILING = false\n\nif $LUSTY_PROFILING\n  require 'rubygems'\n  require 'ruby-prof'\nend\n\n\nmodule VIM\n\n  unless const_defined? \"MOST_POSITIVE_INTEGER\"\n    MOST_POSITIVE_INTEGER = 2**(32 - 1) - 2  # Vim ints are signed 32-bit.\n  end\n\n  def self.zero?(var)\n    # In Vim 7.2 and older, VIM::evaluate returns Strings for boolean\n    # expressions; in later versions, Fixnums.\n    case var\n    when String\n      var == \"0\"\n    when Fixnum\n      var == 0\n    else\n      LustyJ::assert(false, \"unexpected type: #{var.class}\")\n    end\n  end\n\n  def self.nonzero?(var)\n    not zero?(var)\n  end\n\n  def self.evaluate_bool(var)\n    nonzero? evaluate(var)\n  end\n\n  def self.exists?(s)\n    nonzero? evaluate(\"exists('#{s}')\")\n  end\n\n  def self.has_syntax?\n    nonzero? evaluate('has(\"syntax\")')\n  end\n\n  def self.has_ext_maparg?\n    # The 'dict' parameter to mapargs() was introduced in Vim 7.3.32\n    nonzero? evaluate('v:version > 703 || (v:version == 703 && has(\"patch32\"))')\n  end\n\n  def self.columns\n    evaluate(\"&columns\").to_i\n  end\n\n  def self.lines\n    evaluate(\"&lines\").to_i\n  end\n\n  def self.getcwd\n    evaluate(\"getcwd()\")\n  end\n\n  def self.bufname(i)\n    if evaluate_bool(\"empty(bufname(#{i}))\")\n      \"<Unknown #{i}>\"\n    else\n      evaluate(\"bufname(#{i})\")\n    end\n  end\n\n  def self.single_quote_escape(s)\n    # Everything in a Vim single-quoted string is literal, except single\n    # quotes.  Single quotes are escaped by doubling them.\n    s.gsub(\"'\", \"''\")\n  end\n\n  def self.regex_escape(s)\n    s.gsub(/[\\]\\[.~\"^$\\\\*]/,'\\\\\\\\\\0')\n  end\n\n  class Buffer\n    def modified?\n      VIM::nonzero? VIM::evaluate(\"getbufvar(#{number()}, '&modified')\")\n    end\n\n    def listed?\n      VIM::nonzero? VIM::evaluate(\"getbufvar(#{number()}, '&buflisted')\")\n    end\n\n    def self.obj_for_bufnr(n)\n      # There's gotta be a better way to do this...\n      (0..VIM::Buffer.count-1).each do |i|\n        obj = VIM::Buffer[i]\n        return obj if obj.number == n\n      end\n\n      return nil\n    end\n  end\n\n  # Print with colours\n  def self.pretty_msg(*rest)\n    return if rest.length == 0\n    return if rest.length % 2 != 0\n\n    command \"redraw\"  # see :help echo-redraw\n    i = 0\n    while i < rest.length do\n      command \"echohl #{rest[i]}\"\n      command \"echon '#{rest[i+1]}'\"\n      i += 2\n    end\n\n    command 'echohl None'\n  end\nend\n\n# Hack for wide CJK characters.\nif VIM::exists?(\"*strwidth\")\n  module VIM\n    def self.strwidth(s)\n      # strwidth() is defined in Vim 7.3.\n      evaluate(\"strwidth('#{single_quote_escape(s)}')\").to_i\n    end\n  end\nelse\n  module VIM\n    def self.strwidth(s)\n      s.length\n    end\n  end\nend\n\nif VIM::exists?(\"*fnameescape\")\n  module VIM\n    def self.filename_escape(s)\n      # Escape slashes, open square braces, spaces, sharps, double\n      # quotes and percent signs, and remove leading ./ for files in\n      # pwd.\n      single_quote_escaped = single_quote_escape(s)\n      evaluate(\"fnameescape('#{single_quote_escaped}')\").sub(/^\\.\\//,\"\")\n    end\n  end\nelse\n  module VIM\n    def self.filename_escape(s)\n      # Escape slashes, open square braces, spaces, sharps, double\n      # quotes and percent signs, and remove leading ./ for files in\n      # pwd.\n      s.gsub(/\\\\/, '\\\\\\\\\\\\').gsub(/[\\[ #\"%]/, '\\\\\\\\\\0').sub(/^\\.\\//,\"\")\n    end\n  end\nend\n\n\n# Utility functions.\nmodule LustyJ\n\n  unless const_defined? \"MOST_POSITIVE_FIXNUM\"\n    # Per <https://github.com/sjbach/lusty/issues/80>, this computation causes\n    # an error in MacVim.  Since in usage the value doesn't matter too much\n    # as long as it's high, overriding.\n    #MOST_POSITIVE_FIXNUM = 2**(0.size * 8 -2) -1\n    MOST_POSITIVE_FIXNUM = 2**(16 - 1) - 2\n  end\n\n  def self.simplify_path(s)\n    s = s.gsub(/\\/+/, '/')  # Remove redundant '/' characters\n    begin\n      if s[0] == ?~\n        # Tilde expansion - First expand the ~ part (e.g. '~' or '~steve')\n        # and then append the rest of the path.  We can't just call\n        # expand_path() or it'll throw on bad paths.\n        s = File.expand_path(s.sub(/\\/.*/,'')) + \\\n            s.sub(/^[^\\/]+/,'')\n      end\n\n      if s == '/'\n        # Special-case root so we don't add superfluous '/' characters,\n        # as this can make Cygwin choke.\n        s\n      elsif ends_with?(s, File::SEPARATOR)\n        File.expand_path(s) + File::SEPARATOR\n      else\n        dirname_expanded = File.expand_path(File.dirname(s))\n        if dirname_expanded == '/'\n          dirname_expanded + File.basename(s)\n        else\n          dirname_expanded + File::SEPARATOR + File.basename(s)\n        end\n      end\n    rescue ArgumentError\n      s\n    end\n  end\n\n  def self.longest_common_prefix(paths)\n    prefix = paths[0]\n    paths.each do |path|\n      for i in 0...prefix.length\n        if path.length <= i or prefix[i] != path[i]\n          prefix = prefix[0...i]\n          prefix = prefix[0..(prefix.rindex('/') or -1)]\n          break\n        end\n      end\n    end\n\n    prefix\n  end\n\n  def self.ready_for_read?(io)\n    if io.respond_to? :ready?\n      ready?\n    else\n      result = IO.select([io], nil, nil, 0)\n      result && (result.first.first == io)\n    end\n  end\n\n  def self.ends_with?(s1, s2)\n    tail = s1[-s2.length, s2.length]\n    tail == s2\n  end\n\n  def self.starts_with?(s1, s2)\n    head = s1[0, s2.length]\n    head == s2\n  end\n\n  def self.option_set?(opt_name)\n    opt_name = \"g:LustyExplorer\" + opt_name\n    VIM::evaluate_bool(\"exists('#{opt_name}') && #{opt_name} != '0'\")\n  end\n\n  def self.profile\n    # Profile (if enabled) and provide better\n    # backtraces when there's an error.\n\n    if $LUSTY_PROFILING\n      if not RubyProf.running?\n        RubyProf.measure_mode = RubyProf::WALL_TIME\n        RubyProf.start\n      else\n        RubyProf.resume\n      end\n    end\n\n    begin\n      yield\n    rescue Exception => e\n      puts e\n      puts e.backtrace\n    end\n\n    if $LUSTY_PROFILING and RubyProf.running?\n      RubyProf.pause\n    end\n  end\n\n  class AssertionError < StandardError ; end\n\n  def self.assert(condition, message = 'assertion failure')\n    raise AssertionError.new(message) unless condition\n  end\n\n  def self.d(s)\n    # (Debug print)\n    $stderr.puts s\n  end\nend\n\n\nmodule LustyJ\nclass BaseLustyJuggler\n  public\n    def initialize\n      @running = false\n      @last_pressed = nil\n      @name_bar = NameBar.new(alpha_buffer_keys)\n      @ALPHA_BUFFER_KEYS = Hash.new\n      alpha_buffer_keys.each_with_index {|x, i| @ALPHA_BUFFER_KEYS[x] = i + 1}\n      @NUMERIC_BUFFER_KEYS = {\n        \"1\" => 1,\n        \"2\" => 2,\n        \"3\" => 3,\n        \"4\" => 4,\n        \"5\" => 5,\n        \"6\" => 6,\n        \"7\" => 7,\n        \"8\" => 8,\n        \"9\" => 9,\n        \"0\" => 10,\n        \"10\" => 10\n      }\n      @BUFFER_KEYS = @ALPHA_BUFFER_KEYS.merge(@NUMERIC_BUFFER_KEYS)\n      @KEYPRESS_KEYS = {\n        # Can't use '<CR>' as an argument to :call func for some reason.\n        \"<CR>\" => \"ENTER\",\n        \"<Tab>\" => \"TAB\",\n\n        # Split opener keys\n        \"v\" => \"v\",\n        \"b\" => \"b\",\n\n        # Left and Right keys\n        \"<Esc>OD\" => \"Left\",\n        \"<Esc>OC\" => \"Right\",\n        \"<Left>\" => \"Left\",\n        \"<Right>\" => \"Right\",\n      }\n      @KEYPRESS_MAPPINGS = @BUFFER_KEYS.merge(@KEYPRESS_KEYS)\n    end\n\n    def cancel_mappings\n      @cancel_mappings ||= (default_cancel_mappings - alpha_buffer_keys)\n    end\n\n    def run\n      if $lj_buffer_stack.length <= 1\n        VIM::pretty_msg(\"PreProc\", \"No other buffers\")\n        return\n      end\n\n      # If already running, highlight next buffer\n      if @running and LustyJuggler::alt_tab_mode_active?\n        @last_pressed = (@last_pressed % $lj_buffer_stack.length) + 1;\n        print_buffer_list(@last_pressed)\n        return\n      end\n\n      return if @running\n      @running = true\n\n      # Need to zero the timeout length or pressing 'g' will hang.\n      @timeoutlen = VIM::evaluate(\"&timeoutlen\")\n      @ruler = VIM::evaluate_bool(\"&ruler\")\n      @showcmd = VIM::evaluate_bool(\"&showcmd\")\n      @showmode = VIM::evaluate_bool(\"&showmode\")\n      VIM::set_option 'timeoutlen=0'\n      VIM::set_option 'noruler'\n      VIM::set_option 'noshowcmd'\n      VIM::set_option 'noshowmode'\n\n      @key_mappings_map = Hash.new { |hash, k| hash[k] = [] }\n\n      # Selection keys.\n      @KEYPRESS_MAPPINGS.each_pair do |c, v|\n        map_key(c, \":call <SID>LustyJugglerKeyPressed('#{v}')<CR>\")\n      end\n\n      # Cancel keys.\n      cancel_mappings.each do |c|\n        map_key(c, \":call <SID>LustyJugglerCancel()<CR>\")\n      end\n\n      @last_pressed = 2 if LustyJuggler::alt_tab_mode_active?\n      print_buffer_list(@last_pressed)\n    end\n\n    def key_pressed()\n      c = VIM::evaluate(\"a:code_arg\")\n\n      if @last_pressed.nil? and c == 'ENTER'\n        cleanup()\n      elsif @last_pressed and (@BUFFER_KEYS[c] == @last_pressed or c == 'ENTER')\n        choose(@last_pressed)\n        cleanup()\n      elsif @last_pressed and %w(v b).include?(c)\n        c=='v' ? vsplit(@last_pressed) : hsplit(@last_pressed)\n        cleanup()\n      elsif c == 'Left'\n        @last_pressed = (@last_pressed.nil?) ? 0 : (@last_pressed)\n        @last_pressed = (@last_pressed - 1) < 1 ? $lj_buffer_stack.length : (@last_pressed - 1)\n        print_buffer_list(@last_pressed)\n      elsif c == 'Right'\n        @last_pressed = (@last_pressed.nil?) ? 0 : (@last_pressed)\n        @last_pressed = (@last_pressed + 1) > $lj_buffer_stack.length ? 1 : (@last_pressed + 1)\n        print_buffer_list(@last_pressed)\n      else\n        @last_pressed = @BUFFER_KEYS[c]\n        print_buffer_list(@last_pressed)\n      end\n    end\n\n    # Restore settings, mostly.\n    def cleanup\n      @last_pressed = nil\n\n      VIM::set_option \"timeoutlen=#{@timeoutlen}\"\n      VIM::set_option \"ruler\" if @ruler\n      VIM::set_option \"showcmd\" if @showcmd\n      VIM::set_option \"showmode\" if @showmode\n\n      @KEYPRESS_MAPPINGS.keys.each do |c|\n        unmap_key(c)\n      end\n      cancel_mappings.each do |c|\n        unmap_key(c)\n      end\n\n      @running = false\n      VIM::message ' '\n      VIM::command 'redraw'  # Prevents \"Press ENTER to continue\" message.\n    end\n\n  private\n    def self.alt_tab_mode_active?\n       return (VIM::exists?(\"g:LustyJugglerAltTabMode\") and\n               VIM::evaluate(\"g:LustyJugglerAltTabMode\").to_i != 0)\n    end\n\n    def print_buffer_list(highlighted_entry = nil)\n      # If the user pressed a key higher than the number of open buffers,\n      # highlight the highest (see also BufferStack.num_at_pos()).\n\n      @name_bar.selected_buffer = \\\n        if highlighted_entry\n          # Correct for zero-based array.\n          [highlighted_entry, $lj_buffer_stack.length].min - 1\n        else\n          nil\n        end\n\n      @name_bar.print\n    end\n\n    def choose(i)\n      buf = $lj_buffer_stack.num_at_pos(i)\n      VIM::command \"b #{buf}\"\n    end\n    \n    def vsplit(i)\n      buf = $lj_buffer_stack.num_at_pos(i)\n      VIM::command \"vert sb #{buf}\"\n    end\n    \n    def hsplit(i)\n      buf = $lj_buffer_stack.num_at_pos(i)\n      VIM::command \"sb #{buf}\"\n    end\n\n    def map_key(key, action)\n      ['n','s','x','o','i','c','l'].each do |mode|\n        VIM::command \"let s:maparg_holder = maparg('#{key}', '#{mode}')\"\n        if VIM::evaluate_bool(\"s:maparg_holder != ''\")\n          orig_rhs = VIM::evaluate(\"s:maparg_holder\")\n          if VIM::has_ext_maparg?\n            VIM::command \"let s:maparg_dict_holder = maparg('#{key}', '#{mode}', 0, 1)\"\n            nore    = VIM::evaluate_bool(\"s:maparg_dict_holder['noremap']\") ? 'nore'      : ''\n            silent  = VIM::evaluate_bool(\"s:maparg_dict_holder['silent']\")  ? ' <silent>' : ''\n            expr    = VIM::evaluate_bool(\"s:maparg_dict_holder['expr']\")    ? ' <expr>'   : ''\n            buffer  = VIM::evaluate_bool(\"s:maparg_dict_holder['buffer']\")  ? ' <buffer>' : ''\n            restore_cmd = \"#{mode}#{nore}map#{silent}#{expr}#{buffer} #{key} #{orig_rhs}\"\n          else\n            nore = LustyJ::starts_with?(orig_rhs, '<Plug>') ? '' : 'nore'\n            restore_cmd = \"#{mode}#{nore}map <silent> #{key} #{orig_rhs}\"\n          end\n          @key_mappings_map[key] << [ mode, restore_cmd ]\n        end\n        VIM::command \"#{mode}noremap <silent> #{key} #{action}\"\n      end\n    end\n\n    def unmap_key(key)\n      #first, unmap lusty_juggler's maps\n      ['n','s','x','o','i','c','l'].each do |mode|\n        VIM::command \"#{mode}unmap <silent> #{key}\"\n      end\n\n      if @key_mappings_map.has_key?(key)\n        @key_mappings_map[key].each do |a|\n          mode, restore_cmd = *a\n          # for mappings that have on the rhs \\|, the \\ is somehow stripped\n          restore_cmd.gsub!(\"|\", \"\\\\|\")\n          VIM::command restore_cmd\n        end\n      end\n    end\n\n    def default_cancel_mappings\n      [\n        \"i\",\n        \"I\",\n        \"A\",\n        \"c\",\n        \"C\",\n        \"o\",\n        \"O\",\n        \"S\",\n        \"r\",\n        \"R\",\n        \"q\",\n        \"<Esc>\",\n        \"<C-c>\",\n        \"<BS>\",\n        \"<Del>\",\n        \"<C-h>\"\n      ]\n    end\n  end\n\n  class LustyJuggler < BaseLustyJuggler\n    private\n    def alpha_buffer_keys\n      [\n        \"a\",\n        \"s\",\n        \"d\",\n        \"f\",\n        \"g\",\n        \"h\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \";\",\n      ]\n    end\n\n  end\n\n  class LustyJugglerDvorak < LustyJuggler\n    private\n      def alpha_buffer_keys\n        [\n          \"a\",\n          \"o\",\n          \"e\",\n          \"u\",\n          \"i\",\n          \"d\",\n          \"h\",\n          \"t\",\n          \"n\",\n          \"s\"\n        ]\n      end\n  end\n\n  class LustyJugglerColemak < LustyJuggler\n    private\n      def alpha_buffer_keys\n        [\n          \"a\",\n          \"r\",\n          \"s\",\n          \"t\",\n          \"d\",\n          \"h\",\n          \"n\",\n          \"e\",\n          \"i\",\n          \"o\",\n        ]\n      end\n  end\n\n  class LustyJugglerBepo < LustyJuggler\n    private\n    def alpha_buffer_keys\n      [\n        \"a\",\n        \"u\",\n        \"i\",\n        \"e\",\n        \",\",\n        \"t\",\n        \"s\",\n        \"r\",\n        \"n\",\n        \"m\",\n      ]\n    end\n  end\n\n  class LustyJugglerAzerty < LustyJuggler\n    private\n    def alpha_buffer_keys\n      [\n        \"q\",\n        \"s\",\n        \"d\",\n        \"f\",\n        \"g\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \"m\",\n        \"ù\",\n      ]\n    end\n    end\nend\n\n# An item (delimiter/separator or buffer name) on the NameBar.\nmodule LustyJ\nclass BarItem\n  def initialize(str, color)\n    @str = str\n    @color = color\n  end\n\n  def length\n    @str.length\n  end\n\n  def pretty_print_input\n    [@color, @str]\n  end\n\n  def [](*rest)\n    return BarItem.new(@str[*rest], @color)\n  end\n\n  def self.full_length(array)\n    if array\n      array.inject(0) { |sum, el| sum + el.length }\n    else\n      0\n    end\n  end\nend\n\nclass BufferItem < BarItem\n  def initialize(str, highlighted)\n    @str = str\n    @highlighted = highlighted\n    destructure()\n  end\n\n  def [](*rest)\n    return BufferItem.new(@str[*rest], @highlighted)\n  end\n\n  def pretty_print_input\n    @array\n  end\n\n  private\n    @@BUFFER_COLOR = \"PreProc\"\n    #@@BUFFER_COLOR = \"None\"\n    @@DIR_COLOR = \"Directory\"\n    @@SLASH_COLOR = \"Function\"\n    @@HIGHLIGHTED_COLOR = \"Question\"\n\n    # Breakdown the string to colourize each part.\n    def destructure\n      if @highlighted\n        buf_color = @@HIGHLIGHTED_COLOR\n        dir_color = @@HIGHLIGHTED_COLOR\n        slash_color = @@HIGHLIGHTED_COLOR\n      else\n        buf_color = @@BUFFER_COLOR\n        dir_color = @@DIR_COLOR\n        slash_color = @@SLASH_COLOR\n      end\n\n      pieces = @str.split(File::SEPARATOR, -1)\n\n      @array = []\n      @array << dir_color\n      @array << pieces.shift\n      pieces.each { |piece|\n        @array << slash_color\n        @array << File::SEPARATOR\n        @array << dir_color\n        @array << piece\n      }\n\n      # Last piece is the actual name.\n      @array[-2] = buf_color\n    end\nend\n\nclass SeparatorItem < BarItem\n  public\n    def initialize\n      super(@@TEXT, @@COLOR)\n    end\n\n  private\n    @@TEXT = \"|\"\n    #@@COLOR = \"NonText\"\n    @@COLOR = \"None\"\nend\n\nclass LeftContinuerItem < BarItem\n  public\n    def initialize\n      super(@@TEXT, @@COLOR)\n    end\n\n    def self.length\n      @@TEXT.length\n    end\n\n  private\n    @@TEXT = \"<\"\n    @@COLOR = \"NonText\"\nend\n\nclass RightContinuerItem < BarItem\n  public\n    def initialize\n      super(@@TEXT, @@COLOR)\n    end\n\n    def self.length\n      @@TEXT.length\n    end\n\n  private\n    @@TEXT = \">\"\n    @@COLOR = \"NonText\"\nend\n\nend\n\n\n# A one-line display of the open buffers, appearing in the command display.\nmodule LustyJ\nclass NameBar\n  public\n    def initialize(letters)\n      @selected_buffer = nil\n      @LETTERS = letters\n    end\n\n    attr_writer :selected_buffer\n\n    def print\n      items = create_items()\n\n      selected_item = \\\n        if @selected_buffer\n          # Account for the separators we've added.\n          [@selected_buffer * 2, (items.length - 1)].min\n        end\n\n      clipped = clip(items, selected_item)\n      NameBar.do_pretty_print(clipped)\n    end\n\n\n    def create_items\n      names = $lj_buffer_stack.names(10)\n\n      items = names.inject([]) { |array, name|\n        key = if VIM::exists?(\"g:LustyJugglerShowKeys\")\n                case VIM::evaluate(\"g:LustyJugglerShowKeys\").to_s\n                when /[[:alpha:]]/\n                  @LETTERS[array.size / 2] + \":\"\n                when /[[:digit:]]/\n                  \"#{((array.size / 2) + 1) % 10}:\"\n                else\n                  \"\"\n                end\n              else\n                \"\"\n              end\n\n        array << BufferItem.new(\"#{key}#{name}\",\n                            (@selected_buffer and \\\n                             name == names[@selected_buffer]))\n        array << SeparatorItem.new\n      }\n      items.pop   # Remove last separator.\n\n      return items\n    end\n\n    # Clip the given array of items to the available display width.\n    def clip(items, selected)\n      # This function is pretty hard to follow...\n\n      # Note: Vim gives the annoying \"Press ENTER to continue\" message if we\n      # use the full width.\n      columns = VIM::columns() - 1\n\n      if BarItem.full_length(items) <= columns\n        return items\n      end\n\n      selected = 0 if selected.nil?\n      half_displayable_len = columns / 2\n\n      # The selected buffer is excluded since it's basically split between\n      # the sides.\n      left_len = BarItem.full_length items[0, selected - 1]\n      right_len = BarItem.full_length items[selected + 1, items.length - 1]\n\n      right_justify = (left_len > half_displayable_len) and \\\n                      (right_len < half_displayable_len)\n\n      selected_str_half_len = (items[selected].length / 2) + \\\n                              (items[selected].length % 2 == 0 ? 0 : 1)\n\n      if right_justify\n        # Right justify the bar.\n        first_layout = self.method :layout_right\n        second_layout = self.method :layout_left\n        first_adjustment = selected_str_half_len\n        second_adjustment = -selected_str_half_len\n      else\n        # Left justify (sort-of more likely).\n        first_layout = self.method :layout_left\n        second_layout = self.method :layout_right\n        first_adjustment = -selected_str_half_len\n        second_adjustment = selected_str_half_len\n      end\n\n      # Layout the first side.\n      allocation = half_displayable_len + first_adjustment\n      first_side, remainder = first_layout.call(items,\n                                                selected,\n                                                allocation)\n\n      # Then layout the second side, also grabbing any unused space.\n      allocation = half_displayable_len + \\\n                   second_adjustment + \\\n                   remainder\n      second_side, remainder = second_layout.call(items,\n                                                  selected,\n                                                  allocation)\n\n      if right_justify\n        second_side + first_side\n      else\n        first_side + second_side\n      end\n    end\n\n    # Clip the given array of items to the given space, counting downwards.\n    def layout_left(items, selected, space)\n      trimmed = []\n\n      i = selected - 1\n      while i >= 0\n        m = items[i]\n        if space > m.length\n          trimmed << m\n          space -= m.length\n        elsif space > 0\n          trimmed << m[m.length - (space - LeftContinuerItem.length), \\\n                       space - LeftContinuerItem.length]\n          trimmed << LeftContinuerItem.new\n          space = 0\n        else\n          break\n        end\n        i -= 1\n      end\n\n      return trimmed.reverse, space\n    end\n\n    # Clip the given array of items to the given space, counting upwards.\n    def layout_right(items, selected, space)\n      trimmed = []\n\n      i = selected\n      while i < items.length\n        m = items[i]\n        if space > m.length\n          trimmed << m\n          space -= m.length\n        elsif space > 0\n          trimmed << m[0, space - RightContinuerItem.length]\n          trimmed << RightContinuerItem.new\n          space = 0\n        else\n          break\n        end\n        i += 1\n      end\n\n      return trimmed, space\n    end\n\n    def NameBar.do_pretty_print(items)\n      args = items.inject([]) { |array, item|\n        array = array + item.pretty_print_input\n      }\n\n      VIM::pretty_msg *args\n    end\nend\n\nend\n\n\n# Maintain MRU ordering.\nmodule LustyJ\nclass BufferStack\n  public\n    def initialize\n      @stack = []\n\n      (0..VIM::Buffer.count-1).each do |i|\n        @stack << VIM::Buffer[i].number\n      end\n    end\n\n    # Switch to the previous buffer (the one you were using before the\n    # current one).  This is basically a smarter replacement for :b#,\n    # accounting for the situation where your previous buffer no longer\n    # exists.\n    def juggle_previous\n      buf = num_at_pos(2)\n      VIM::command \"b #{buf}\"\n    end\n\n    def names(n = :all)\n      # Get the last n buffer names by MRU.  Show only as much of\n      # the name as necessary to differentiate between buffers of\n      # the same name.\n      cull!\n      names = @stack.collect { |i| VIM::bufname(i) }.reverse\n      if n != :all\n        names = names[0,n]\n      end\n      shorten_paths(names)\n    end\n\n    def numbers(n = :all)\n      # Get the last n buffer numbers by MRU.\n      cull!\n      numbers = @stack.reverse\n      if n == :all\n        numbers\n      else\n        numbers[0,n]\n      end\n    end\n\n    def num_at_pos(i)\n      cull!\n      return @stack[-i] ? @stack[-i] : @stack.first\n    end\n\n    def length\n      cull!\n      return @stack.length\n    end\n\n    def push\n      buf_number = VIM::evaluate('expand(\"<abuf>\")').to_i\n      @stack.delete buf_number\n      @stack << buf_number\n    end\n\n    def pop\n      number = VIM::evaluate('bufnr(expand(\"<abuf>\"))')\n      @stack.delete number\n    end\n\n  private\n    def cull!\n      # Remove empty and unlisted buffers.\n      @stack.delete_if { |x|\n        not (VIM::evaluate_bool(\"bufexists(#{x})\") and\n             VIM::evaluate_bool(\"getbufvar(#{x}, '&buflisted')\"))\n      }\n    end\n\n    # NOTE: very similar to Entry::compute_buffer_entries()\n    def shorten_paths(buffer_names)\n      # Shorten each buffer name by removing all path elements which are not\n      # needed to differentiate a given name from other names.  This usually\n      # results in only the basename shown, but if several buffers of the\n      # same basename are opened, there will be more.\n\n      # Group the buffers by common basename\n      common_base = Hash.new { |hash, k| hash[k] = [] }\n      buffer_names.each do |name|\n        basename = Pathname.new(name).basename.to_s\n        common_base[basename] << name\n      end\n\n      # Determine the longest common prefix for each basename group.\n      basename_to_prefix = {}\n      common_base.each do |k, names|\n        if names.length > 1\n          basename_to_prefix[k] = LustyJ::longest_common_prefix(names)\n        end\n      end\n\n      # Shorten each buffer_name by removing the prefix.\n      buffer_names.map { |name|\n        base = Pathname.new(name).basename.to_s\n        prefix = basename_to_prefix[base]\n        prefix ? name[prefix.length..-1] \\\n               : base\n      }\n    end\nend\n\nend\n\n\n\nif VIM::exists?('g:LustyJugglerKeyboardLayout') and VIM::evaluate_bool('g:LustyJugglerKeyboardLayout == \"dvorak\"')\n  $lusty_juggler = LustyJ::LustyJugglerDvorak.new\nelsif VIM::exists?('g:LustyJugglerKeyboardLayout') and VIM::evaluate_bool('g:LustyJugglerKeyboardLayout == \"colemak\"')\n  $lusty_juggler = LustyJ::LustyJugglerColemak.new\nelsif VIM::exists?('g:LustyJugglerKeyboardLayout') and VIM::evaluate_bool('g:LustyJugglerKeyboardLayout == \"bépo\"')\n\t$lusty_juggler = LustyJ::LustyJugglerBepo.new\nelsif VIM::exists?('g:LustyJugglerKeyboardLayout') and VIM::evaluate_bool('g:LustyJugglerKeyboardLayout == \"azerty\"')\n\t$lusty_juggler = LustyJ::LustyJugglerAzerty.new\nelse \n  $lusty_juggler = LustyJ::LustyJuggler.new\nend\n$lj_buffer_stack = LustyJ::BufferStack.new\n\nEOF\n\n\" vim: set sts=2 sw=2:\n","markers":{"markers":{"1":{"id":1,"range":[[299,0],[299,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":7,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/rwarner/Dropbox/config/.vimbundles/lusty/plugin/lusty-juggler.vim","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0b8ff7a307c7c7d875d264d0715f57f908c34f8e","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":7,"softTabs":true,"scrollTop":3546,"scrollLeft":0,"displayBuffer":{"id":8,"softWrap":false,"editorWidthInChars":89,"tokenizedBuffer":{"bufferPath":"/Users/rwarner/Dropbox/config/.vimbundles/lusty/plugin/lusty-juggler.vim","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/rwarner/Dropbox/config/.vimbundles/lusty/plugin/lusty-juggler.vim","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{}},"fuzzy-finder":{"/Users/rwarner/Dropbox/config/.vimbundles/lusty/plugin/lusty-juggler.vim":1396621543899},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":257329978},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/rwarner/Dropbox/config/.vimbundles/lusty/plugin/lusty-juggler.vim","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}